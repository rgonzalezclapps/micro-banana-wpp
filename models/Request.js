/**
 * models/Request.js
 * 
 * Description: MongoDB model for parallel request processing system with Google Gemini integration
 * 
 * Role in the system: Manages micro-conversations for image processing requests parallel to main conversations
 * 
 * Node.js Context: Model - MongoDB document schema for request management
 * 
 * Dependencies:
 * - mongoose (MongoDB ODM)
 * 
 * Dependants:
 * - modules/requestManager.js (business logic)
 * - modules/openaiIntegration.js (tool execution)
 * - services/googleGeminiService.js (AI processing)
 */

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

// Schema for input images uploaded by users
const InputImageSchema = new Schema({
  fileId: {
    type: String,
    required: true // Crypto-secure file ID from our storage system
  },
  filename: {
    type: String,
    required: true // Original or secure filename
  },
  originalPrompt: {
    type: String,
    required: false // User prompt when this image was added
  },
  addedAt: {
    type: Date,
    default: Date.now
  }
});

// Schema for output images generated by Gemini - ENHANCED for multiple response support
const OutputImageSchema = new Schema({
  fileId: {
    type: String,
    required: true // Our storage file ID for generated image
  },
  filename: {
    type: String,
    required: true // Generated filename
  },
  geminiResponse: {
    type: String,
    required: false // Text response from Gemini along with image
  },
  generatedAt: {
    type: Date,
    default: Date.now
  },
  // NEW: Multiple response support
  responseOrder: {
    type: Number,
    required: true,
    default: 0 // Order in multi-image response
  },
  responseType: {
    type: String,
    enum: ['image', 'text', 'image_with_text'],
    default: 'image'
  },
  associatedText: {
    type: String,
    required: false // Text that goes with this image
  },
  isMultipleResponse: {
    type: Boolean,
    default: false // Part of multi-image response
  }
});

// Schema for processing history and iterations
const ProcessingHistorySchema = new Schema({
  iteration: {
    type: Number,
    required: true
  },
  prompt: {
    type: String,
    required: true // Full prompt sent to Gemini
  },
  result: {
    type: String,
    required: false // Text result from Gemini
  },
  processedAt: {
    type: Date,
    default: Date.now
  },
  processingTime: {
    type: Number,
    required: false // Processing time in milliseconds
  },
  errorDetails: {
    type: String,
    required: false // Error message if processing failed
  }
});

// NEW: Schema for Gemini conversation history (user/model turns with parts)
const ConversationHistorySchema = new Schema({
  role: {
    type: String,
    enum: ['user', 'model'],
    required: true
  },
  parts: [{
    type: {
      type: String,
      enum: ['text', 'image'],
      required: true
    },
    content: {
      type: String,
      required: true // Text content or fileId for images
    },
    mimeType: {
      type: String,
      required: false // Only for images (image/jpeg, image/png, etc.)
    },
    addedAt: {
      type: Date,
      default: Date.now
    }
  }],
  addedAt: {
    type: Date,
    default: Date.now
  }
});

// Main Request schema for parallel micro-conversations
const RequestSchema = new Schema({
  // Relationship to main conversation system
  conversationId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'Conversation'
  },
  participantId: {
    type: Number,
    required: true // Reference to MongoDB ParticipantProfile.participantId
  },
  participantName: {
    type: String,
    required: false,
    default: 'Unknown'
  },
  
  // Request status and metadata
  status: {
    type: String,
    enum: ['active', 'processing', 'completed', 'error', 'cancelled'],
    default: 'active'
  },
  type: {
    type: String,
    enum: ['image_processing', 'photo_product', 'image_editing', 'custom'],
    default: 'image_processing'
  },
  
  // Processing configuration
  systemPrompt: {
    type: String,
    required: true // Custom system instruction for Gemini
  },
  maxIterations: {
    type: Number,
    default: 10 // Prevent infinite processing loops
  },
  currentIteration: {
    type: Number,
    default: 0
  },
  
  // File management
  inputImages: [InputImageSchema],
  outputImages: [OutputImageSchema],
  
  // Processing tracking
  instructions: [{
    type: String,
    required: true // Accumulated user instructions over time
  }],
  processingHistory: [ProcessingHistorySchema],
  
  // NEW: Gemini conversation history for context building
  conversationHistory: [ConversationHistorySchema],
  
  // Error handling
  lastError: {
    code: String,
    message: String,
    timestamp: Date
  },
  retryCount: {
    type: Number,
    default: 0
  },
  
  // Timestamps and TTL
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  },
  expiresAt: {
    type: Date,
    default: () => new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days TTL
    index: { expireAfterSeconds: 0 } // MongoDB TTL index
  }
}, {
  timestamps: true // Automatically manage createdAt and updatedAt
});

// Indexes for performance optimization
RequestSchema.index({ conversationId: 1, status: 1 });
RequestSchema.index({ participantId: 1, createdAt: -1 });
RequestSchema.index({ status: 1, updatedAt: -1 });
RequestSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 }); // TTL index

// Pre-save middleware to update timestamps and iteration tracking
RequestSchema.pre('save', function(next) {
  this.updatedAt = new Date();
  
  // Update current iteration based on processing history
  if (this.processingHistory && this.processingHistory.length > 0) {
    this.currentIteration = Math.max(...this.processingHistory.map(h => h.iteration));
  }
  
  next();
});

// Instance methods for request management
RequestSchema.methods.addInputImage = function(fileId, filename, originalPrompt = '') {
  this.inputImages.push({
    fileId,
    filename,
    originalPrompt,
    addedAt: new Date()
  });
  return this.save();
};

// ENHANCED: Support for multiple response outputs with metadata
RequestSchema.methods.addOutputImage = function(fileId, filename, geminiResponse = '', options = {}) {
  const {
    responseOrder = 0,
    responseType = 'image',
    associatedText = '',
    isMultipleResponse = false
  } = options;

  this.outputImages.push({
    fileId,
    filename,
    geminiResponse,
    responseOrder,
    responseType,
    associatedText,
    isMultipleResponse,
    generatedAt: new Date()
  });
  return this.save();
};

// NEW: Add multiple output images from a single Gemini response
RequestSchema.methods.addMultipleOutputs = function(outputs = []) {
  outputs.forEach((output, index) => {
    this.outputImages.push({
      fileId: output.fileId,
      filename: output.filename,
      geminiResponse: output.geminiResponse || '',
      responseOrder: index,
      responseType: output.responseType || 'image',
      associatedText: output.associatedText || '',
      isMultipleResponse: outputs.length > 1,
      generatedAt: new Date()
    });
  });
  return this.save();
};

RequestSchema.methods.addInstruction = function(instruction) {
  this.instructions.push(instruction);
  return this.save();
};

// NEW: Conversation history management for Gemini context building
RequestSchema.methods.addToConversationHistory = function(role, parts = []) {
  this.conversationHistory.push({
    role,
    parts,
    addedAt: new Date()
  });
  return this.save();
};

RequestSchema.methods.addUserTurnToHistory = function(textContent, imageFileIds = []) {
  const parts = [];
  
  // Add text part if provided
  if (textContent && textContent.trim()) {
    parts.push({
      type: 'text',
      content: textContent.trim(),
      addedAt: new Date()
    });
  }
  
  // Add image parts if provided
  imageFileIds.forEach(fileId => {
    parts.push({
      type: 'image',
      content: fileId,
      mimeType: 'image/jpeg', // Default, should be determined from actual file
      addedAt: new Date()
    });
  });
  
  if (parts.length > 0) {
    return this.addToConversationHistory('user', parts);
  }
  
  return Promise.resolve(this);
};

RequestSchema.methods.addModelTurnToHistory = function(textResponse = '', generatedImageFileIds = []) {
  const parts = [];
  
  // Add text part if provided
  if (textResponse && textResponse.trim()) {
    parts.push({
      type: 'text',
      content: textResponse.trim(),
      addedAt: new Date()
    });
  }
  
  // Add generated image parts
  generatedImageFileIds.forEach(fileId => {
    parts.push({
      type: 'image',
      content: fileId,
      mimeType: 'image/png', // Gemini typically generates PNG
      addedAt: new Date()
    });
  });
  
  if (parts.length > 0) {
    return this.addToConversationHistory('model', parts);
  }
  
  return Promise.resolve(this);
};

RequestSchema.methods.addProcessingHistory = function(prompt, result, processingTime, errorDetails = null) {
  const iteration = this.currentIteration + 1;
  this.processingHistory.push({
    iteration,
    prompt,
    result,
    processingTime,
    errorDetails,
    processedAt: new Date()
  });
  this.currentIteration = iteration;
  return this.save();
};

RequestSchema.methods.setError = function(errorCode, errorMessage) {
  this.status = 'error';
  this.lastError = {
    code: errorCode,
    message: errorMessage,
    timestamp: new Date()
  };
  this.retryCount += 1;
  return this.save();
};

RequestSchema.methods.setProcessing = function() {
  this.status = 'processing';
  return this.save();
};

RequestSchema.methods.setCompleted = function() {
  this.status = 'completed';
  return this.save();
};

// Static methods for request queries
RequestSchema.statics.findActiveByConversation = function(conversationId) {
  return this.find({
    conversationId,
    status: { $in: ['active', 'processing'] }
  }).sort({ updatedAt: -1 });
};

RequestSchema.statics.findByParticipant = function(participantId, limit = 10) {
  return this.find({ participantId })
    .sort({ createdAt: -1 })
    .limit(limit);
};

RequestSchema.statics.cleanup = function() {
  // Manual cleanup for old requests (in addition to TTL)
  const cutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days
  return this.deleteMany({
    $or: [
      { status: 'completed', updatedAt: { $lt: cutoffDate } },
      { status: 'error', retryCount: { $gte: 3 }, updatedAt: { $lt: cutoffDate } },
      { status: 'cancelled', updatedAt: { $lt: cutoffDate } }
    ]
  });
};

// Export the Request model
const Request = mongoose.model('Request', RequestSchema);

module.exports = Request;
