/**
 * models/Request.js
 * 
 * Description: MongoDB model for parallel request processing system with Google Gemini integration
 * 
 * Role in the system: Manages micro-conversations for image processing requests parallel to main conversations
 * 
 * Node.js Context: Model - MongoDB document schema for request management
 * 
 * Dependencies:
 * - mongoose (MongoDB ODM)
 * 
 * Dependants:
 * - modules/requestManager.js (business logic)
 * - modules/openaiIntegration.js (tool execution)
 * - services/googleGeminiService.js (AI processing)
 */

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

// Schema for input images uploaded by users
const InputImageSchema = new Schema({
  fileId: {
    type: String,
    required: true // Crypto-secure file ID from our storage system
  },
  filename: {
    type: String,
    required: true // Original or secure filename
  },
  originalPrompt: {
    type: String,
    required: false // User prompt when this image was added
  },
  addedAt: {
    type: Date,
    default: Date.now
  }
});

// Schema for output images generated by Gemini
const OutputImageSchema = new Schema({
  fileId: {
    type: String,
    required: true // Our storage file ID for generated image
  },
  filename: {
    type: String,
    required: true // Generated filename
  },
  geminiResponse: {
    type: String,
    required: false // Text response from Gemini along with image
  },
  generatedAt: {
    type: Date,
    default: Date.now
  }
});

// Schema for processing history and iterations
const ProcessingHistorySchema = new Schema({
  iteration: {
    type: Number,
    required: true
  },
  prompt: {
    type: String,
    required: true // Full prompt sent to Gemini
  },
  result: {
    type: String,
    required: false // Text result from Gemini
  },
  processedAt: {
    type: Date,
    default: Date.now
  },
  processingTime: {
    type: Number,
    required: false // Processing time in milliseconds
  },
  errorDetails: {
    type: String,
    required: false // Error message if processing failed
  }
});

// Main Request schema for parallel micro-conversations
const RequestSchema = new Schema({
  // Relationship to main conversation system
  conversationId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'Conversation'
  },
  participantId: {
    type: Number,
    required: true // Reference to PostgreSQL Participant
  },
  participantName: {
    type: String,
    required: false,
    default: 'Unknown'
  },
  
  // Request status and metadata
  status: {
    type: String,
    enum: ['active', 'processing', 'completed', 'error', 'cancelled'],
    default: 'active'
  },
  type: {
    type: String,
    enum: ['image_processing', 'photo_product', 'image_editing', 'custom'],
    default: 'image_processing'
  },
  
  // Processing configuration
  systemPrompt: {
    type: String,
    required: true // Custom system instruction for Gemini
  },
  maxIterations: {
    type: Number,
    default: 10 // Prevent infinite processing loops
  },
  currentIteration: {
    type: Number,
    default: 0
  },
  
  // File management
  inputImages: [InputImageSchema],
  outputImages: [OutputImageSchema],
  
  // Processing tracking
  instructions: [{
    type: String,
    required: true // Accumulated user instructions over time
  }],
  processingHistory: [ProcessingHistorySchema],
  
  // Error handling
  lastError: {
    code: String,
    message: String,
    timestamp: Date
  },
  retryCount: {
    type: Number,
    default: 0
  },
  
  // Timestamps and TTL
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  },
  expiresAt: {
    type: Date,
    default: () => new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days TTL
    index: { expireAfterSeconds: 0 } // MongoDB TTL index
  }
}, {
  timestamps: true // Automatically manage createdAt and updatedAt
});

// Indexes for performance optimization
RequestSchema.index({ conversationId: 1, status: 1 });
RequestSchema.index({ participantId: 1, createdAt: -1 });
RequestSchema.index({ status: 1, updatedAt: -1 });
RequestSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 }); // TTL index

// Pre-save middleware to update timestamps and iteration tracking
RequestSchema.pre('save', function(next) {
  this.updatedAt = new Date();
  
  // Update current iteration based on processing history
  if (this.processingHistory && this.processingHistory.length > 0) {
    this.currentIteration = Math.max(...this.processingHistory.map(h => h.iteration));
  }
  
  next();
});

// Instance methods for request management
RequestSchema.methods.addInputImage = function(fileId, filename, originalPrompt = '') {
  this.inputImages.push({
    fileId,
    filename,
    originalPrompt,
    addedAt: new Date()
  });
  return this.save();
};

RequestSchema.methods.addOutputImage = function(fileId, filename, geminiResponse = '') {
  this.outputImages.push({
    fileId,
    filename,
    geminiResponse,
    generatedAt: new Date()
  });
  return this.save();
};

RequestSchema.methods.addInstruction = function(instruction) {
  this.instructions.push(instruction);
  return this.save();
};

RequestSchema.methods.addProcessingHistory = function(prompt, result, processingTime, errorDetails = null) {
  const iteration = this.currentIteration + 1;
  this.processingHistory.push({
    iteration,
    prompt,
    result,
    processingTime,
    errorDetails,
    processedAt: new Date()
  });
  this.currentIteration = iteration;
  return this.save();
};

RequestSchema.methods.setError = function(errorCode, errorMessage) {
  this.status = 'error';
  this.lastError = {
    code: errorCode,
    message: errorMessage,
    timestamp: new Date()
  };
  this.retryCount += 1;
  return this.save();
};

RequestSchema.methods.setProcessing = function() {
  this.status = 'processing';
  return this.save();
};

RequestSchema.methods.setCompleted = function() {
  this.status = 'completed';
  return this.save();
};

// Static methods for request queries
RequestSchema.statics.findActiveByConversation = function(conversationId) {
  return this.find({
    conversationId,
    status: { $in: ['active', 'processing'] }
  }).sort({ updatedAt: -1 });
};

RequestSchema.statics.findByParticipant = function(participantId, limit = 10) {
  return this.find({ participantId })
    .sort({ createdAt: -1 })
    .limit(limit);
};

RequestSchema.statics.cleanup = function() {
  // Manual cleanup for old requests (in addition to TTL)
  const cutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days
  return this.deleteMany({
    $or: [
      { status: 'completed', updatedAt: { $lt: cutoffDate } },
      { status: 'error', retryCount: { $gte: 3 }, updatedAt: { $lt: cutoffDate } },
      { status: 'cancelled', updatedAt: { $lt: cutoffDate } }
    ]
  });
};

// Export the Request model
const Request = mongoose.model('Request', RequestSchema);

module.exports = Request;
